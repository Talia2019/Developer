# 📚 CPU Scheduling

<br>

<br>

## 1. Scheduling 개요

<br>

##### CPU 스케줄러

> 프로세스가 생성된 후 종료될 때까지 모든 상태변화를 조정

<br>

##### CPU 스케줄링

> CPU를 효율적으로 사용하기 위해 어떤 프로세스에 CPU를 배정할지 결정

<br>

##### 목적

| 목적           | 설명                                                                           |
| -------------- | ------------------------------------------------------------------------------ |
| 공평성         | 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되면 안됨 |
| 효율성         | 시스템 자원을 놀리는 시간 없이 스케줄링 해야함                                 |
| 안정성         | 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야함                   |
| 반응 시간 보장 | 적절한 시간 안에 프로세스의 요구에 반응해야 함                                 |
| 무한 연기 방지 | 특정 프로세스의 작업이 무한이 연기되어서는 안됨                                |

<br>

## 2. Scheduling 단계

<br>

- 고수준 스케줄링(long-term scheduling, job scheduling, admissin scheduling)

  가장 큰 틀에서 이루어지는 CPU 스케줄링으로 시스템 내의 전체 작업 수를 조절

  시스템 과부하를 막기 위해 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정하므로 시스템 내에서 동작 시에 실행 가능한 프로세스의 총개수가 정해짐

→

- 중간 수준 스케줄링

  중지(suspend)와 활성화(active)로 전체 시스템의 활성화된 프로세스 수를 조절

  이로 인해 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할

→

- 저수준 스케줄링(short-term scheduling)

  가장 작은 단위의 스케줄링으로 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 역할

  중간 수준의 스케줄링은 프로세스를 보류 상태로 보내고, 저수준 스케줄링은 대기 상태로 보냄

  스케줄링에 대해 공부하는 대부분의 내용이 이 저수준 스케줄링에 해당

<br>

## 3. Scheduling 고려사항

<br>

- preemptive vs non-preemptive

선점형 스케줄링 : 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식

CPU 처리 시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능

하지만 잦은 문맥 교환으로 오버헤드가 많이 발생

비선점형 스케줄링 : 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식

필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 남

<br>

- CPU bound vs I/O bound

프로세스가 대기 상태에 있다가 CPU를 할당받아 실행하면 CPU burst, 입출력 작업을 하면 I/O burst라고 함

CPU bound process(CPU 집중 프로세스) : CPU를 많이 사용하여 CPU burst가 많은 프로세스

I/O bound process(입출력 집중 프로세스) : 입출력을 많이 사용해 I/O burst가 많은 프로세스

두 프로세스가 같이 대기상태에 있다면 입출력 집중 프로세스에 먼저 CPU를 할당시키는 것이 더 효율적

(입출력 집중 프로세스는 CPU를 빠르게 쓰고 입출력 버스트를 하러 나가기 때문에 다른 프로세스가 오래 기다리지 않아도 되기 때문)

<br>

- 전면 프로세스 vs 후면 프로세스

전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓여 현재 입출력이 사용되고, 사용자와 상호작용이 가능해 상호작용 프로세스라고도 불림 (워드 프로세스)

후면 프로세스 : 사용자의 입력 없이 작동하여 일괄 작업 프로세스라고 불림 (압축 프로세스)

전면 프로세스는 사용자의 요구에 즉각 즉각 반응해야 하지만 후면 프로세스는 그럴 필요가 없으므로 전면 프로세스를 먼저 처리해 줘야 함

<br>

- 프로세스 우선순위

CPU 스케줄러 대부분은 프로세스에 우선순위를 매겨 우선순위가 높은(우선순위 숫자가 작은) 프로세스부터 처리되도록 함

커널 프로세스 > 일반 프로세스

전면 프로세스 > 후면 프로세스

대화형 프로세스 > 일괄 처리 프로세스

입출력 집중 프로세스 > CPU 집중 프로세스

<br>

## 4. Scheduling 성능 척도

작업을 마치는 것 : 프로세스가 종료된것이 아니라, CPU입장에서 프로세스가 들어와 작업을 처리하고 나갔을때를 말함

<br>

### CPU 입장

- CPU utilization(CPU 사용률)

시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법으로 최대한 CPU를 바쁘게 만드는 것

가장 이상적인 수치는 100%

- Throughput(처리량)

단위 시간당 작업을 마친 프로세스의 수

즉, CPU 버스트를 처리한 수

<br>

### 프로세스 입장

- Turn-around time(반환 시간)

프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간

프로세스의 대기 시간 + 실행시간

여기서 대기 시간은 없을 수도 있고, 1 번일 수도, 여러 번일수도 있음

- Waiting time(대기 시간)

프로세스가 CPU를 할당받아 실행되기 전 대기 상태일 때의 시간

보통 준비 큐에서 대기를 하는 시간

- Response time(응답 시간)

프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간

대기 시간과의 차이점은 대기 시간은 반환 시간과 마찬가지로 여러 번 있을 수 있음

그 총합이 대기 시간이고, 응답 시간은 최초의 한 번

이 응답 시간은 프로세스 입장에서 CPU를 한 번도 못 얻은 것과 한 번이라도 얻는 것은 사용자 응답에 있어서 중요한 차이가 있기 때문에 중요

<br>

## 5. Scheduling 알고리즘

| 종류            | 예                        |
| --------------- | ------------------------- |
| 비선점 스케줄링 | FCFS                      |
|                 | SJF                       |
|                 | HRN                       |
| 선점 스케줄링   | Priority Scheduling       |
|                 | Round Robin               |
|                 | Multilevel-Queue          |
|                 | Multilevel-Feedback-Queue |

<br>

#### FCFS (First Come First Served)

`선입선출` 방식으로, 준비 큐에 도착한 순서대로 CPU를 할당하는 `비선점형` 방식

모든 프로세스의 우선순위가 동일하고, 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 매우 단순하고 공평한 방법

하지만 CPU 처리 시간이 긴 프로세스가 앞에 올 경우 뒤의 프로세스가 한없이 기다려야 하기 때문에 비효율적이게 됨(이를 콘보이 효과라 함)

<br>

#### SJF (Shortest Job First)

준비 큐에 있는 프로세스 중 `실행 시간이 가장 짧은` 작업부터 CPU를 할당하는 `비선점형` 방식

늦게 도착하더라도 CPU 처리 시간이 앞에 대기중인 프로세스보다 짧으면 먼저 CPU를 할당받을 수 있기에 콘보이 효과를 완화 가능

단, 비선점형 방식이기 때문에 CPU를 사용중인 프로세스보다 처리 시간이 짧더라도 빼앗지는 못함

FCFS보다 효율성이 매우 높지만 그에 따른 단점도 존재

가장 중요한 공평성에 어긋남. 처리 시간이 긴 프로세스의 경우 처리 시간이 짧은 프로세스가 계속해서 들어온다면 대기 큐에서 영영 CPU를 할당받지 못할 수 있음(이를 starvation 현상이라고 함)

또한 중간에 입출력 버스트가 빈번하게 요구되는 프로세스의 경우 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어려움

<br>

#### HRN(Highest Response Ratio Next)

SJF 스케줄링에 `Aging` 기법을 합친 `비선점형` 알고리즘

Aging이란 나이를 먹는다는 의미 그대로 starvation을 해결하기 위해 대기 시간이 길어지면 우선순위를 높여주는 방법

SJF와 마찬가지로 실행 시간이 적은 프로세스의 우선 순위가 높지만 대기 시간이 너무 길어지면 실행 시간이 길더라도 CPU를 할당받을 수 있음

하지만 여전히 공평성이 말끔히 해결되지는 않음

<br>

#### SRTF (Shortest Remaning Time First)

`SJF`의 `선점형` 방식

먼저 온 프로세스가 CPU를 할당받고 있더라도 남은 처리 시간이 뒤에 온 프로세스의 처리 시간보다 길면 CPU를 빼앗김

어떤 알고리즘보다 평균 대기 시간이 가장 짧은 알고리즘

하지만 선점형 방식이기 때문에 잦은 문맥교환이 일어나고 그에 따른 오버헤드가 커짐

또한 starvation 현상이 더 심각하게 발생할 수 있고, CPU의 예상 시간을 예측하기가 너무 힘들기 때문에 실제로 사용되기가 매우 어려움(exponential averaging을 통해 예측 가능하긴 함)

<br>

#### Priority Scheduling

프로세스의 중요도에 따라 매긴 `우선순위`를 반영한 알고리즘으로 위에서 알아본 SJF, HRN, SRTF도 우선순위 스케줄링 알고리즘의 일종

starvation 문제와 공평성 문제가 있음

<br>

#### RR(Round Robin)

프로세스에게 각각 동일한 `CPU 할당 시간`(타임 슬라이스, quantum)을 부여해서 이 시간 동안만 CPU를 이용

만약 할당 시간동안 처리를 다 하지 못하면 CPU를 빼앗고 다음 프로세스에게 넘김(`선점형`)

빼앗긴 프로세스는 준비 큐의 맨 뒤로 감

따로 CPU 처리 시간을 계산하지 않아도 돼서 선점형 방식의 가장 단순하고 대표적인 방법

우선 순위도 없기 때문에 매우 공평

할당 시간이 q고 대기 중인 프로세스가 n개라면 어떤 프로세스도 (n-1)q 이상을 기다리지 않아도 되기에 모든 프로세스가 최초 응답 시간을 빠르게 보장받을 수 있다는 큰 장점을 가짐(콘베이 효과 줄어듦)

가장 중요한 부분은 타임 슬라이스의 크기 결정

타임 슬라이스가 큰 경우 처리 시간이 긴 프로세스에 의해 CPU의 효율성이 떨어질 수 있음

타임 슬라이스가 작은 경우 여러 프로그램이 동시에 실행되는 효과를 볼 수 있으나 잦은 문맥 교환이 일어나 오버헤드가 커짐

적당한 타임 슬라이스를 설정하는 것이 중요(10~100ms)

<br>

#### Multilevel Queue

우선순위에 따라 준비 큐를 여러 개 사용하는 방식

우선순위가 높은 큐에 먼저 CPU가 할당되어 큐에 속한 모든 프로세스가 처리되야 다음 우선순위 큐가 실행될 수 있음

한 번 우선순위가 매겨저 준비 큐에 들어가면 이 우선순위는 바뀌지 않음

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLqYAc%2FbtqtW0lcMXw%2FkM2ex6H9lu5f2tSfjoRgvK%2Fimg.png)

각 큐는 독립적인 스케줄링 알고리즘을 가질 수 있는데, 보통 전면 프로세스들이 속해있는 큐는 우선순위가 높고 라운드 로빈 스케줄링을 사용해 타임 슬라이스를 작게함

후면 프로세스에는 사용자와의 상호작용이 없으므로 가장 간단한 FCFS 방식으로 처리

보통 총 CPU 시간이 전면 프로세스의 처리에 80%, 후면 프로세스 처리에 20%가 할당됨

starvation 현상과 공평성 문제를 지님

<br>

#### Multilevel Feedback Queue

다단계 큐의 공평성 문제를 완화하기 위해 신분 하락이 가능한 알고리즘

우선순위가 변동되기 때문에 큐 사이의 이동이 가능

한 번 CPU를 할당받은 프로세스는 우선순위가 조금 낮아져 더 낮은 큐로 이동 (우선순위가 높아지면 상위 큐로 이동)

우선순위가 높은 큐보다 우선순위가 낮은 큐에 타임 슬라이스 크기를 크게 줌

<br>

> 출처
> https://bnzn2426.tistory.com/65
