# 📚 Paging & Segmentation

<br>

<br>

## 기법을 쓰는 이유

> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문



<br>

## 메모리 관리 기법

1. 연속 메모리 관리

   > 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함

   고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 (내부 단편화)
   
   동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 (단편화 발생)

   <br>

2. 불연속 메모리 관리

   > 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

   `페이지` : 고정 사이즈의 작은 프로세스 조각

   `프레임` : 페이지 크기와 같은 주기억장치 메모리 조각

   `단편화` : 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상

   `세그먼트` : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것
   
   `페이징`: 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방식

   `세그먼테이션`: 논리적 내용 단위인 세그먼트로 잘라서 메모리에 적재하는 방식 (일반적으로 세그먼트들의 크기는 다름)

   `가상 메모리` : 실제 메모리 크기와 상관없이 메모리를 사용 할 수 있도록 가상 메모리 주소를 사용 하는 것 (프로세스의 일부분만 메모리에 로드하고, 나머지는 보조기억장치 (가상메모리 공간))

   `내부 단편화` : 할당 된 단위보다 적은 용량의 프로그램이 적재되어 공간이 낭비되는 것

   `외부 단편화` : 작업보다 많은 공간이 남아있더라도, 그 작업을 받아 들이지 못하는 것

   <br>

   **고정 크기** : 페이징(Paging)

   **가변 크기** : 세그먼테이션(Segmentation)

   <br>

   - 단순 페이징

     > 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
     >
     > 내부 단편화 O

   - 단순 세그먼테이션

     > 각 프로세스는 여러 세그먼트들로 나뉨
     >
     > 외부 단편화 O, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소

   - 가상 메모리 페이징

     > 필요하지 않은 페이지들은 로드되지 
     >
     > 필요한 페이지가 있으면 나중에 자동으로 불러들어짐
     >
     > 내부 단편화 O
     >
     > 복잡한 메모리 관리로 오버헤드 발생

   - 가상 메모리 세그먼테이션

     > 필요하지 않은 세그먼트들은 로드되지 않음
     >
     > 필요한 세그먼트 있을때 나중에 자동으로 불러들어짐
     >
     > 외부 단편화 O
     >
     > 복잡한 메모리 관리로 오버헤드 발생

<br>

## 가상 메모리란?

![image](https://user-images.githubusercontent.com/55391944/146197794-38b7189a-9fc7-4a43-ba1e-53a8f72ae51d.png)

메모리를 관리하는 방법의 하나. 각 프로그램에 실제(물리) 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식(메모리가 실제 메모리보다 많아 보이게 함)

가상 메모리(프로세스가 참조하는 주소)와 물리 메모리(실제 메모리 주소)의 매핑을 위한 기술로 페이징 기법이 사용됨

Page : 가상 메모리를 사용하는 최소 크기 단위

MMU : Memory Management Unit. CPU가 메모리에 접근하는것을 관리하는 장치. virtual address를 physical address로 바꿔줌

<br>
