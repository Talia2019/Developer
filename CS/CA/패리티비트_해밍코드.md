# 📚 패리티 비트 & 해밍 코드

<br>

데이터 송수신 과정 오류검사(에러가 발생했는지, 어디서 발생했는지..)중 가장 대표적이고 간단한 방법이 패리티 비트

<br>

## 1. 패리티 비트

정보 전달 과정에서 오류가 생겼는 지 검사하기 위해 추가하는 비트
(1의 개수가 홀수인지 짝수인지 체크하기 위해 추가되는 비트)

전송하고자 하는 데이터에 1비트를 더하여 전송하기에 오류가 홀수개일땐 검출이 되나, 오류가 짝수개 일때는 검출 불가능

오류 발생 여부만 알 수 있고 오류 수정은 불가능

코드내의 1의 개수에 따라 홀수패리티와 짝수패리티로 나뉨

<br>

**종류** : 짝수, 홀수 패리티

전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것

<br>

**_짝수 패리티일 때 7비트 데이터가 1010001라면?_**

> 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함
>
> 답 : 11010001 (맨앞이 패리티비트)
> <br>

## 2. 해밍 코드

<br>

데이터비트에 여러개의 패리티비트를 추가하여 오류를 검출하고 정정할 수 있는 코드

패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정

(패리티 비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)

<br>

#### 패리티 비트 공식

> $2^p \geq p + n + 1$  
> n = 데이터 비트 수  
> p = 패리티 비트 추가 개수
> 만약 데이터비트가 14라면 이진수로 1110이기에 n = 4고 p = 3이면 8로 딱 맞아 떨어지기에 4자리수는 패리티코드를 3개 넣는다고함  
> 패리티는 $2^x$자리에 삽입

![image](https://user-images.githubusercontent.com/55391944/147071734-7b8509d6-9bb6-4ec0-af90-63e43564026b.png)

<br>

#### 방법

2의 n승 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로 부터 시작한다. 이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.

> 예)  
> 14 (이진수 1110)의 경우 패리티가 1,2,4자리에 들어가서  
> ? ? 1 ? 1 1 0 (?는 패리티비트 들어갈 자리, 1110은 데이터)  
> (홀수패리티)  
> 첫번째 패리티비트는 패리티비교표에 따라 1,3,5,7번째 비트를 보는데, 총 1이 2개 있으므로 1이 됨  
> 두번째 패리티비트는 패리티비교표에 따라 2,3,6,7번째 비트를 봐서 1이 2개이므로 1이 됨  
> 세번째 패리티 비트는 표에 따라 4,5,6,7비트를 보는데 1이 2개이므로 1이 됨  
> 정상 해밍코드 : 1 1 1 1 1 1 0
>
> 오류비교 (1111110)  
> $2^0$ : 1,3,5,7을 봤을때 1이 3개이므로 오류여부 0  
> $2^1$ : 2,3,6,7을 봤을때 1이 3개이므로 오류여부 0  
> $2^2$ : 4,5,6,7을 봤을때 1이 3개이므로 오류여부 0  
> 오류가 000이면 오류가 없는것이므로 3,5,6,7번째 숫자가 그대로 데이터가 됨
>
> 오류비교 (1101110)  
> $2^0$ : 1,3,5,7을 봤을때 1이 2개이므로 오류여부 1  
> $2^1$ : 2,3,6,7을 봤을때 1이 2개이므로 오류여부 1  
> $2^2$ : 4,5,6,7을 봤을때 1이 3개 이므로 오류여부 0  
> 오류가 011이므로 3번째 위치가 잘못된것

<br>

**_짝수 패리티의 해밍 코드가 0011011일때 오류가 수정된 코드는?_**

1. 1, 3, 5, 7번째 비트 확인 : 0101로 짝수이므로 '0'

2. 2, 3, 6, 7번째 비트 확인 : 0111로 홀수이므로 '1'

3. 4, 5, 6, 7번째 비트 확인 : 1011로 홀수이므로 '1'

<br>

역순으로 패리티비트 '110'을 도출했다. 10진법으로 바꾸면 '6'으로, 6번째 비트를 수정하면 된다.

따라서 **정답은 00110'0'1**이다.

<br>

> 참고  
> https://www.youtube.com/watch?v=CLy9O81SXlU
