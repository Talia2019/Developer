# 📚 Design Pattern 개요

> 일종의 설계 기법이며, 설계 방법

<br>

## 1. 목적

  SW **재사용성, 호환성, 유지 보수성**을 보장

  <br>

## 2. 특징

  **디자인 패턴은 아이디어** 이며, 특정한 구현이 아님

  프로젝트에 항상 적용해야 하는 것은 아니지만, 추후 재사용, 호환, 유지 보수시 발생하는 **문제 해결을 예방하기 위해 패턴을 만들어 둔 것**

  <br>

## 3. 원칙

  #### SOLID (객체지향 설계 원칙)

  1. ##### Single Responsibility Principle

     > 하나의 클래스는 하나의 역할만 해야 함

  2. ##### Open - Close Principle

     > 확장 (상속)에는 열려있고, 수정에는 닫혀 있어야 함

  3. ##### Liskov Substitution Principle

     > 자식이 부모의 자리에 항상 교체될 수 있어야 함

  4. ##### Interface Segregation Principle

     > 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야함

  5. ##### Dependency Inversion Property

     > 상위 모듈이 하위 모듈에 의존하면 안됨
     >
     > 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존하면 안됨

<br>

## 4. 분류 (중요)

`3가지 패턴의 목적을 이해하기!`

1. 생성 패턴 (Creational) : 객체의 **생성 방식** 결정

   - 추상 팩토리(Abstract Factory)

        구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴

   - 팩토리 메서드(Factory Method)
   
        객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴

   - 싱글턴(Singleton)

        전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴

   ```text
   예) DBConnection을 관리하는 Instance를 하나만 만들 수 있도록 제한하여, 불필요한 연결을 막음.
   ```

   <br>

2. 구조 패턴 (Structural) : 객체간의 **관계**를 조직

   - 컴퍼지트(Composite)

         여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴

   - 데커레이터(Decorator)

         객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴

   ```text
   예) 2개의 인터페이스가 서로 호환이 되지 않을 때, 둘을 연결해주기 위해서 새로운 클래스를 만들어서 연결시킬 수 있도록 함.
   ```

   <br>

3. 행위 패턴 (Behavioral): 객체의 **행위**를 조직, 관리, 연합

    - 옵서버(Observer)

         한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴

    - 스테이트(State)

         객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴

    - 스트래티지(Strategy)

         행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴

    - 템플릿 메서드(Template Method)

         어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴

    - 커맨드(Command)

         실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
